# Workshop Organizer Web API

Welcome to **Workshop Organizer Web API**. This API helps run public workshops (registrations, sessions, resources).

## Table of Contents

1. Context  
2. Technical Overview  
3. Run Locally (without Docker)  
4. Run with Docker (Compose)  
5. Configuration  
6. Testing  
7. CI/CD (GitHub Actions)  
8. Docker Images & Publishing to GHCR  

## 1) Context

Workshops are a great way to foster learning and collaboration. This API aims to simplify the management of participants, sessions, and resources.

## 2) Technical Overview

- **JDK / Runtime:** the Docker runtime image uses **Eclipse Temurin JRE 21**.  
- **Build:** multi-stage Docker build with **Gradle 8.7 + JDK 21**, and the project uses Gradle.  
- **Spring Boot:** **Spring Boot 3.2.4**.  
- **Database:** **PostgreSQL 16 Alpine**.  
- **API Port:** exposed on **8080**.  

## 3) Run Locally (without Docker)

### Prerequisites

- JDK 21  
- Gradle wrapper (`./gradlew`)  

### Compile

```bash
./gradlew clean compileJava
```

Run
```bash
./gradlew bootRun
```

4) Run with Docker (docker compose)
Start the API + PostgreSQL
```bash
docker compose up -d
```
API: http://localhost:8080

PostgreSQL: workshop-db container (data persisted using the pgdata volume)

Stop
```bash
docker compose down
```
Remove data too (volume)
```bash
docker compose down -v
```
5) Configuration
Main (Spring) environment variables
SPRING_DATASOURCE_URL (e.g. jdbc:postgresql://db:5432/workshopsdb)

SPRING_DATASOURCE_USERNAME

SPRING_DATASOURCE_PASSWORD

Default values with Docker Compose
Default values are already defined in docker-compose.yml:

DB: workshopsdb

user: workshops_user

password: oc2024

6) Testing
Gradle tests (local)
./gradlew clean test
JUnit reports generated by Gradle
build/test-results/test/*.xml (standard Gradle structure)

Unified test script
The repository includes a run-tests.py script that:

detects the project type

runs unit tests

copies JUnit XML reports into ./test-results/

Run:
```bash
python run-tests.py
```
Example of copied results (Gradle side):

test-results/build/test-results/test/*.xml

7) CI/CD (GitHub Actions)
The CI workflow is generic: it works for this Java/Gradle repo (and can be identical on the Angular repo following the same approach).

test job
installs the required tooling (Java/Gradle or Node depending on the repo)

runs python run-tests.py

publishes JUnit reports (XML files under test-results/**/*.xml)

build job
builds the Docker image from the Dockerfile

pushes to GitHub Container Registry (GHCR) with a readable tag:

branch-SHA (e.g. main-<sha>)

release job
runs on main

executes semantic-release

creates a GitHub Release (tag vX.Y.Z)

also pushes a Docker image tagged with the semantic version: X.Y.Z

8) Docker Images & Publishing to GHCR
Image name
The workflow pushes the image to:

ghcr.io/<owner>/<repo> (computed automatically in the workflow)

Published tags
branch-SHA (e.g. ci-test-<sha>, main-<sha>)

X.Y.Z (after release)

GitHub prerequisites (important)
For GHCR push + release to work, the repository must allow the GitHub Actions token:

Settings → Actions → General → Workflow permissions → Read and write permissions

Quality notes
docker-compose.yml uses a PostgreSQL healthcheck (pg_isready) and depends_on: condition: service_healthy to avoid starting the app before the database is ready.

The backend Dockerfile is multi-stage (build then runtime), which avoids shipping Gradle in the final image.

::contentReference[oaicite:0]{index=0}